---
title: "001-大话设计模式-简单工厂模式"
date: 2019-07-02T18:11:32+08:00
author: Mr-CoderLeftEar
categories: ["设计模式"]
tags: ["设计模式"]
draft: true
---

# 简单工厂模式
---

## 一、需求
使用java实现一个计算器计算功能

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/staticFactory.png)


## 二、初步实现

```
public class Operation_first {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		
		System.out.print("第一个数：");
		int numberA = sc.nextInt();
		
		System.out.print("运算符：");
		String operation = sc.next();
		
		System.out.print("第二个数：");
		int numberB = sc.nextInt();
		
		int result = 0;
		
		try {
			//运算
			switch (operation) {
				case "+":
					result = numberA + numberB;
					break;
				case "-":
					result = numberA - numberB;
					break;
				case "*":
					result = numberA * numberB;
					break;
				case "/":
					result = numberA / numberB;
					break;
				default:
					break;
			}
			//打印结果
			System.out.println(result);
		} catch (Exception e) {
			e.getMessage();
		}
	}
}

```

## 三、反思

看见题并开始做题时，采用最直接的方法解决问题。完全没有使用面向对象的编程方法去实现。

对于我来说，遇到问题就完全根据题目要求完成，没有进行深度的思考，只满足当前的题目要求，这样写出来的程序往往是不易维护、不易扩展、不易复用的。达不到高质量的代码要求。

#### 何谓可维护、可扩展、可复用、灵活性好

- 可维护:当程序要改动时，只需要更改需要改动的地方，其他部分无需动作。

- 可扩展:程序需要添加新的功能，可在原基础上直接添加即可。

- 可复用:此程序实现的功能在其他的地方也可以用。

- 灵活性好:程序更改移动极为灵活，不受太多限制。

#### 面向对象程序设计

通过面向对象的封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，便于复用。

## 四、改进措施

**进行封装**

计算机程序分为用户的输入操作和逻辑运算两部分

- 运算类

```
public class Operation {
    public static double getResult(double number1, double number2, String operate){
        double result = 0.0;
        switch (operate) {
            case "+":
                result = number1 + number2;
                break;
            case "-":
                result = number1 - number2;
                break;
            case "*":
                result = number1 * number2;
                break;
            case "/":
                result = number1 / number2;
                break;
        }
        return result;
    }
}
```

- 用户操作类

```
public class Calculator {
    public static void main(String[] args) {
        try {
            Scanner scanner = new Scanner(System.in);

            System.out.print("请输入操作数1：");
            double number1 = scanner.nextDouble();
            System.out.print("请输入操作数2：");
            double number2 = scanner.nextDouble();
            System.out.print("请输入运算符");
            String operate = scanner.next();

            String result = Operation.getResult(number1, number2, operate) + "";
            System.out.println("运算结果：" + result);
        }catch (Exception e){
            System.out.println("发生错误"+e.getMessage());
        }
    }
}
```

- 优点：实现分离，这样运算类在其他程序中也可以被使用，实现可服用。

- 缺点：当给程序添加其运算符时，需要增加switch分支，这样类便需要重新编译。当新增加的部分需要使用加减乘除时，在不知情的情况下，误修改代码，造成损失；只添加一个小功能，却使得原来运行良好的功能代码产生变化，风险太大。

**使用继承和多态**

将所有运算符的共同特点抽取出来，并写成基类形式:

```
public abstract class Operation {
	
	//定义变量
	private double numberA;
	private double numberB;
	
	public double getNumberA() {
		return numberA;
	}
	public void setNumberA(double numberA) {
		this.numberA = numberA;
	}
	public double getNumberB() {
		return numberB;
	}
	public void setNumberB(double numberB) {
		this.numberB = numberB;
	}
	
	//用于继承的类---得到结果
	public abstract double getResult();
	
}
```

其他运算符通过继承的方式来编写:

加法：

```
public class OperationAdd extends Operation {

	@Override
	public double getResult() {
		return getNumberA() + getNumberB();
	}
	
}
```

减法：

```
public class OperationSub extends Operation {

	@Override
	public double getResult() {
		return getNumberA() - getNumberB();
	}
}
```

乘法：

```
public class OperationMul extends Operation {

	@Override
	public double getResult() {
		return getNumberA() * getNumberB();
	}
}
```

除法：

```
public class OperationDiv extends Operation {

	@Override
	public double getResult() {
		//判断除数是否为0
		if(getNumberB() == 0) {
			try {
				throw new Exception("除数不能为0");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return getNumberA() / getNumberB();
	}
}
```

这里就是用了继承的特性，对于如何创建这些运算类的实例对象，则需要使用多态的特性。至于创建哪个运算类实例对象，至于将来会不会增加运算类，比如开根号，这是极其容易变化的地方，应该考虑单独一个类帮助我们实例化对象，这就是**工厂模式**。

## 五、简单工厂模式



```
public class OperationFactory {
	//简单运算工厂方法
	public static Operation createOperation(String operate) {
		//使用多态，创建Operation变量
		Operation oper = null;
		
		switch (operate) {
			case "+":
				//创建加法对象
				oper = new OperationAdd();
				break;
	
			case "-":
				oper = new OperationSub();
				break;
				
			case "*":
				oper = new OperationMul();
				break;
				
			case "/":
				oper = new OperationDiv();
				break;
				
			default:
				break;
		}
		//返回结果
		return oper;
	}
}
```

通过提供运算符，工厂构造出对应的预算类实例，通过多态的方式，返回父类引用。

后期添加开根号运算，只需要写一个开根号运算类继承Operation类，在通过工厂类添加生成实例代码。

如果需更改某个运算类的功能，只需更改相对应的类即可。

```
public class Test {

	public static void main(String[] args) {

		try {
			
			Scanner sc = new Scanner(System.in);
			
			System.out.print("第一个数：");
			double numberA = sc.nextDouble();
			
			System.out.print("运算符：");
			String operation = sc.next();
			
			System.out.print("第二个数：");
			double numberB = sc.nextDouble();
			
			//使用简单运算工厂方法传递运算符
			Operation operate = OperationFactory.createOperation(operation);
			//使用set...方法进行赋值
			operate.setNumberA(numberA);
			operate.setNumberB(numberB);
			//获取结果
			double result = operate.getResult();
			System.out.println(result);
		
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		
	}
	
}
```
