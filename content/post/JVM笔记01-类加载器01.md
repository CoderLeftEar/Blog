---
title: "JVM笔记01-类加载器01"
date: 2019-08-25T11:36:56+08:00
author: CoderLeftEar
tags: ["JVM"]
categories: ["JVM"]
draft: true
---

# 类加载器、类的加载连接与初始化
---

<!-- TOC -->

- [类加载器、类的加载连接与初始化](#类加载器类的加载连接与初始化)
    - [类加载](#类加载)
    - [类加载器](#类加载器)
    - [类的加载、连接与初始化](#类的加载连接与初始化)
    - [类的使用和卸载](#类的使用和卸载)
    - [Java虚拟机对类的使用方式](#java虚拟机对类的使用方式)
    - [**`案例：`**](#案例)
    - [类的加载](#类的加载)
    - [JVM参数](#jvm参数)
    - [关于public static final String str = "hello";](#关于public-static-final-string-str--hello)
        - [反编译](#反编译)
    - [助记符：](#助记符)
    - [数组实例](#数组实例)
    - [父子接口](#父子接口)
    - [案例：关于初始化过程的代码](#案例关于初始化过程的代码)

<!-- /TOC -->


<font color='red' size=6>所有的类一定是由类加载器加载的，但数组例外，数组是由jvm加载的</font>


## 类加载

定义：在Java代码中，`类型`的加载、连接与初始化过程都是在程序运行期间完成的。

`类型`：可以理解为class；这里指的是定义的`class`、`interface`、`枚举`，不存在对象的概念。表示`类本身`，并不表示`对象`。

类型的加载：将已经存在的字节码文件从硬盘上加载到内存中。
连接：将类与类之间的关系固定好，对于字节码的一些相关处理，验证、准备、解析都是在此阶段完成的。

初始化：赋值

-------------------------------------------

## 类加载器

加载类的工具

以下情况，Java虚拟机会结束生命周期：
- 执行了System.exit();
- 程序正常结束。
- 程序在执行过程中遇到了异常或错误而异常终止。
- 由于操作系统出现错误而导致Java虚拟机进程终止。

---------------------------------------

## 类的加载、连接与初始化

1. 加载：查找并加载类的二进制数据（加载类的class文件加载进内存）
2. 连接
    - 验证：确保被加载的类的正确性。（使得class文件时按照jvm的规范进行的）
    - 准备：为类的`静态变量`分配内存，并将其初始化为默认值。
        - class test {
    &emsp;&emsp;private static int a = 1;
    }
    先加载test类，然后将变量a设置为int类型的默认值0。
    - 解析：将符号引用转换为直接引用。
        - 符号引用：通过符号的表示，一个类中的方法通过符号引用另一个类所需的目标。
        - 直接引用：直接将这个方法通过指针指向所需要用的目标的对象的内存中的位置。
3. 初始化：为类的静态变量赋予正确的初始值（a = 1)
4. 类的实例化：
    - 为新的对象分配内存
    - 为实例变量赋默认值
    - 为实例变量赋正确的初始值
    - java编译器为它编译的每个类都至少生成一个实例初始化方法（构造器），在java的class文件中，这个实例初始化方法被称为"`<init>`"（静态变量是"`<clinit>`"）；针对源代码中每个类的构造方法，java编译器都产生一个`<init>`方法。
    =====================
    `另一种对象创建过程：`类加载检查 - 分配内存 - 初始化零值 - 设置对象头 - 执行init方法
5. 垃圾回收和对象终结

-----------------------------------

## 类的使用和卸载

- 使用：用类创建对象、调用方法。
- 卸载：class字节码文件加载到内存中，形成自己的数据结构，驻留在内存中，还可以被销毁。

--------------------------------

## Java虚拟机对类的使用方式  

所有的Java虚拟机实现必须在每个类或接口  被Java程序`首次主动使用`时才初始化它们。

- 主动使用：  
    1. 创建类的实例`(例：Test test = new Test();`
	2. 访问某个类或接口的静态变量，或者对该静态变量赋值`{jvm层面上：1.访问静态变量：调用getstatic助记符（或者虚拟机字节码指令）；2.对静态变量赋值：putstatic助记符（或者虚拟机字节码指令）}`
	3. 调用类的静态方法`（调用invokestatic助记符）`
	4. 反射`（如Class.forName("com.test.Test")）`
	5. 初始化一个类的子类`（public child extends parent{}；初始化子类时，也表示对父类的主动使用。（当初始化child时，也会对parent进行初始化））`
	6. Java虚拟机启动时被标注为启动类的类`（包含main方法的类）`
	7. jdk1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化

- 被动使用：  
    - 除了七种主动使用情况外，其他使用Java类的方法都被看作是对类的被动使用，都不会导致类的初始化（只是不会初始化，加载---连接---初始化）

---------------------------
## **`案例：`**

执行Child1.str1：
- `-XX:+TraceClassLoading`, 添加此段后，编译时会打印jvm的详细加载过程
- 由于是从子类访问父类的静态变量，子类不会主动使用，不会被初始化，父类会初始化，`但子类会被加载`。
- 包含main方法的类也会被加载
> [Loaded com.wang.jvm.ClassLoader from file:/E:/JavaEE/ClassLoad/out/production/classes/]
```
[Loaded com.wang.jvm.Parent1 from file:/E:/JavaEE/ClassLoad/out/production/classes/]
[Loaded com.wang.jvm.Child1 from file:/E:/JavaEE/ClassLoad/out/production/classes/]
Parent static block!
parent
```
执行Child1.str2：  
```
Parent static block!
Child static block!
child
```

- 对于静态字段来说，只有直接定义了该字段的类才会被初始化
- 初始化一个子类，其父类全部都要初始化

str1：访问的时父类的静态变量，只有直接定义了该字段的类才会被初始化
str2：是子类的静态变量，所以会将子类及父类一起初始化

```
public class ClassLoader {
    public static void main(String[] args) {
        System.out.println(Child1.str1);
        //System.out.println(Child1.str2);
    }
}

class Parent1{
    public static String str1 = "parent";
    static {
        System.out.println("Parent static block!");
    }
}

class Child1 extends Parent1{
    public static String str2 = "child";

    static {
        System.out.println("Child static block!");
    }
}
```
答案：
Parent static block!
Child static block!
child

----------------------------------------

## 类的加载  

- 类的加载：指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区中，然后在内存中创建一个java.lang.Class对象（JVM规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。

- 加载.class文件的方式
    1. 从本地直接加载
    2. 网络下载.class文件
    3. zip、jar等归档文件中加载.class文件
    4. 从数据库中提取.class文件
    5. 将Java源文件动态编译为.class文件（动态代理，运行期生成的文件，jsp -> servlet -> .class）

------------------------------

## JVM参数

`-XX:+<option> : 表示开启option选项` 
`-XX:-<option> : 表示关闭option选项`

`--XX:+TraceClassLoading: 用于追踪类的加载信息并打印`
`--XX:+TraceClassUnloading: 用于类在卸载时的信息`

设置jvm空间大小：
`-XX:<option>=<value> : 表示将option选项的值设置为value`

---------------------------------------------

## 关于public static final String str = "hello";

- 添加final后的静态变量，就会存入到`调用这个常量的这个方法的所在的类的常量池当中`,在此例中，就相当于在FianlStatic这个类的常量池当中，之后者两个类之间没有任何关系（甚至可以删除FinalTest编译后的字节码文件，不影响程序正常执行）
- 本质上，调用类并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

```
public class FinalStatic {
    public static void main(String[] args) {
        System.out.println(FinalTest.str);
    }
}

class FinalTest {
    public static final String str = "hello";

    static {
        System.out.println("welcome world!");
    }
}
```

### 反编译

查看详细信息：
javap -c com.wang.jvm.FinalStatic
```
Compiled from "FinalStatic.java"
public class com.wang.jvm.FinalStatic {
  public com.wang.jvm.FinalStatic();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #4                  // String hello
       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

从以上反编译结果看出，在FinalStatic中调用static final的str已经成为了一个值，String类型的hello，助记符为：`ldc`

------------------------------------------

## 助记符：

**源码：**

```
public class ZhuJiFu {

    public static void main(String[] args) {

        System.out.println(Test1.a);
        System.out.println(Test1.b);
        System.out.println(Test1.c);
        System.out.println(Test1.d);

        System.out.println("==================UUID==================");
        System.out.println(Test2.str);
    }
}

class Test1{
    public static final short a = 1;
    public static final int b = 127;
    public static final int c = 234;
    public static final String d = "hello";

    static{
        System.out.println("Hello");
    }
}

class Test2{
    public static final String str = UUID.randomUUID().toString();

    static{
        System.out.println("Hello UUID!");
    }
}
```

**反编译结果：**
```
Compiled from "ZhuJiFu.java"
public class com.wang.jvm.ZhuJiFu {
  public com.wang.jvm.ZhuJiFu();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: iconst_1
       4: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
       7: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      10: bipush        127
      12: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      18: sipush        234
      21: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      24: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      27: ldc           #5                  // String hello
      29: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      32: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      35: ldc           #7                  // String ==================UUID==================
      37: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      40: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      43: getstatic     #8                  // Field com/wang/jvm/Test2.str:Ljava/lang/String;
      46: invokevirtual #6                  // M   ethod java/io/PrintStream.println:(Ljava/lang/String;)V
      49: return
}
```
> **final常量在编译期不知道知道具体的值时，那么这个变量就不会被放到调用这个类的常量池当中，这时在程序运行时，会导致主动使用该常量所在的类，自然就会导致主动使用这个类，被初始化。**

- ldc: 表示将`int`, `float`或是`String`类型的常量值从常量池推送至栈顶
- bipush: 表示将单字节（-128 ~ 127）的常量值推送至栈顶
- sipush: 表示将一个短整型常量值（-32768 ~ 32767）推送至栈顶
- iconst_1: 表示将int类型（数字1）推送至栈顶（数字-1 ~ 5有（iconst_m1 -- iconst_0 ~ iconst_5））

数组相关：
- anewarray: 表示创建一个引用类型数的（如：类、接口、数组）数组，并将其引用值压入栈顶
- newarray: 表示创建一个指定的原始类型（如：int、float、char等）数组，并将其引用值压入栈顶

----------------------------------

## 数组实例
- 创建两个对象实例，却只打印一次`Hello World`, 原因是静态代码块只加载一次（只有在`首次主动使用`才初始化）
- 对于数组实例来说，其类型是由jvm在运行期间动态生成的，一维数组表示为`[Lcom.wang.jvm.Test` 这种形式，动态生成的类型，其父类就是Object。
- 对于数组来说，JavaDoc经常讲构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。
- 原生类型：

```
public class ArraysTest {
    public static void main(String[] args) {
        Test test1 = new Test();
        System.out.println("=======================");
        Test test2 = new Test();

        System.out.println("=================引用类型数组=================");
        Test[] tests = new Test[1];
        System.out.println(tests.getClass());
        System.out.println(tests.getClass().getSuperclass());

        System.out.println("=================引用类型数组=================");
        Test[][] testss = new Test[1][1];
        System.out.println(testss.getClass());
        System.out.println(tests.getClass().getSuperclass());

        System.out.println("=================原始类型数组=================");
        int[] ints = new int[1];
        System.out.println("int: " + ints.getClass());
        System.out.println(tests.getClass().getSuperclass());

        byte[] bytes = new byte[1];
        System.out.println("byte: " + bytes.getClass());

        short[] shorts = new short[1];
        System.out.println("short: " + shorts.getClass());

        long[] longs = new long[1];
        System.out.println("long: " + longs.getClass());

        char[] chars = new char[1];
        System.out.println("char: " + chars.getClass());

        boolean[] booleans = new boolean[1];
        System.out.println("boolean: " + booleans.getClass());

        float[] floats = new float[1];
        System.out.println("float: " + floats.getClass());

        double[] doubles = new double[1];
        System.out.println("double: " + doubles.getClass());

    }
}

class Test{
    static {
        System.out.println("Hello World!");
    }
}

答案：
Hello World!
=======================
=================引用类型数组=================
class [Lcom.wang.jvm.Test;
class java.lang.Object
=================引用类型数组=================
class [[Lcom.wang.jvm.Test;
class java.lang.Object
=================原始类型数组=================
int: class [I
class java.lang.Object
byte: class [B
short: class [S
long: class [J
char: class [C
boolean: class [Z
float: class [F
double: class [D
```
------------------------------------------

## 父子接口

`**interface中的变量默认是final，而Class中的变量不加final，就...**`

- 接口中的变量类型是：`public static final`类型，所有b的值会在InterfaceParenChild的常量池中。
```
public class InterfaceParentChild {
    public static void main(String[] args) {
        System.out.println(Child.b);
    }
}

interface Parent {
    public static final int a = 1;
}

interface  Child extends Parent {
    public static final int b = 2;
}
```

- 当子接口中的b是编译期间生成的，那么父子接口都会被初始化，并且父类的.class文件必须存在。
```
interface  Child extends Parent {
    public static final int b = new Random().nextInt(5);
}

[Loaded com.wang.jvm.Parent from file:/E:/JavaEE/ClassLoad/out/production/classes/]
[Loaded com.wang.jvm.Child from file:/E:/JavaEE/ClassLoad/out/production/classes/]
```

- 当子接口中的b是编译期间生成的，父接口中的a是public static final类型时，此时a处在InterfaceParentChild的常量池当中。

- 当父子接口中的a，b都是编译期间生成的，子接口调用a，父子接口也都需要被初始化。


## 案例：关于初始化过程的代码

<font color=red size=5>初始化过程会先将变量赋默认值0</font>

具体过程已经分析过了，我应该看的懂，不写了 --- 抱歉，我看不懂

```
public class InitTest {
    public static void main(String[] args) {
        //调用InitFun类中的getInstance()方法，该方法返回InitFun类的实例对象，它的构造方法执行a ++, b ++
        //由于调用了InitFun类中的静态方法，所以主动使用了，会发生发生初始化
        InitFun initFun = InitFun.getInstance();

        System.out.println(InitFun.a);
        System.out.println(InitFun.b);
    }
}

class InitFun {
    public static int a;

    public static int b = 0;

    public static InitFun initFun = new InitFun();

    public InitFun(){
        a ++;
        b ++;
    }

//    public static int b = 0;

    public static InitFun getInstance() {
        return initFun;
    }
}

答案：
1
1
将b移到下面时，答案：
1
0
```




