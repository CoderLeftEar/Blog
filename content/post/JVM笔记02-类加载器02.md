---
title: "JVM笔记02 类加载器02"
date: 2019-09-03T20:56:20+08:00
author: CoderLeftEar
tags: ["JVM"]
categories: ["JVM"]
draft: true
---

<!-- TOC -->

- [类加载](#类加载)
    - [类加载过程](#类加载过程)
    - [类的加载](#类的加载)
        - [有两种类型的类加载器](#有两种类型的类加载器)
        - [<font color=red>类加载器并不需要等到某个类被“首次主动使用”是再加载它。</font>](#font-colorred类加载器并不需要等到某个类被首次主动使用是再加载它font)
    - [连接](#连接)
        - [类的连接](#类的连接)
        - [类的准备](#类的准备)
    - [类的初始化](#类的初始化)
        - [类的初始化步骤](#类的初始化步骤)
        - [类初始化的时机](#类初始化的时机)
    - [类加载器的加载、加载器种类及类加载器的关系](#类加载器的加载加载器种类及类加载器的关系)
    - [类加载器的双亲委托机制](#类加载器的双亲委托机制)
        - [案例：](#案例)
    - [双亲委托机制案例：](#双亲委托机制案例)
    - [ClassLoader源码](#classloader源码)
    - [自定义类加载器](#自定义类加载器)
    - [引入命名空间](#引入命名空间)
    - [命名空间](#命名空间)
    - [类的卸载](#类的卸载)
        - [案例：](#案例-1)

<!-- /TOC -->


# 类加载
------------------

## 类加载过程
![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载01.jpg)

---------------------------

## 类的加载  

- 类的加载的最终产品是位于内存中的Class对象
- Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。


### 有两种类型的类加载器

1. Java虚拟机自带的加载器
    - 根类加载器（启动类加载器）（BootStrap）
    - 扩展类加载器（Extension）
    - 系统（应用）类加载器（System / App）
2. 用户自定义的类加载器
    - 一定是java.lang.ClassLoader（抽象类）的子类
    - 用户可以定制类的加载方式


### <font color=red>类加载器并不需要等到某个类被“首次主动使用”是再加载它。</font>

- JVM规范允许类加载器在预料某个类将要被使用时就加载它，如果在预知加载过程中遇到了.class文件缺失或存在错误，类加载器必须在程序`首次主动使用`该类是才报告错误（LinkageError错误）
- 如果这个类一直没有被程序主动使用，那么来加载器就不会报告错误。


## 连接

### 类的连接
- 类被加载后，就进入连接阶段。连接就是将已经读入到内存中的二进制数据合并到虚拟机的运行时环境中去。

- 类的验证的内容（主要部分）：
    - 类文件的结构检查
    - 语义检查
    - 字节码验证
    - 二进制兼容性的验证

### 类的准备

## 类的初始化

### 类的初始化步骤
- 假如这个类还没有被加载和连接，那就先进行加载和连接
- 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句

### 类初始化的时机
- 主动使用（七种）

- 关于接口的初始化
    - jvm初始化一个类时，要求其所有父类已经被初始化，但这条规则并不适用与接口
    - 初始化一个类时，并不会先初始化它所实现的接口

    此时`删除`Parent的字节码文件会`报错`，但并不能证明`Parent会不会被初始化`(但jvm会尝试`加载Parent类`)，`Child一定会被初始化`，Parent字节码文件已经被删除，所以会报错。
    以下可证明，加载一个类时，其继承的父接口不会初始化，但会被jvm加载
    `{}`：初始化代码块，没创建一次对象，就会被调用一次
    `static {}`：与不同，它只调用一次。
    ```
    public class InterfaceParentChild {
        public static void main(String[] args) {
            Child c1 = new Child();
            Child c2 = new Child();
            System.out.println(Child.b);
        }
    }

    interface Parent {
        public static Thread thread = new Thread() {
            {
                System.out.println("Hello!");
            }
        };
    }

    class Child implements Parent {
        {
            System.out.println("child");
        }
        public static int b = 2;
    }

    [Loaded com.wang.jvm.Parent from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    [Loaded com.wang.jvm.Child from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    child
    child
    2
    ```

    - 初始化一个接口时，并不会先初始化它的父接口

    已确定的值：
    此时只加载main方法所在的类，因为接口中变量默认public static final，所有变量在main所在类的常量池当中。

    编译期确定的值：
    就需要加载父子接口，并加载其中的静态对象，如下：（最后一行是Thread重写的toString方法）
    ```
    public class InterfaceParentChild {
        public static void main(String[] args) {
            System.out.println(Child.thread);
        }
    }

    interface Parent {
        public static Thread thread = new Thread() {
            {
                System.out.println("parent!");
            }
        };
    }

    interface Child extends Parent {
        public static Thread thread = new Thread() {
            {
                System.out.println("child!");
            }
        };
    }

    [Loaded com.wang.jvm.Parent from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    [Loaded com.wang.jvm.Child from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    [Loaded com.wang.jvm.Parent$1 from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    [Loaded com.wang.jvm.Child$1 from file:/E:/JavaEE/ClassLoad/out/production/classes/]
    child!
    Thread[Thread-0,5,main]
    ```
    
    - 父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致接口的初始化。
- 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

-------------------------

## 类加载器的加载、加载器种类及类加载器的关系

类加载器的加载：
![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载器00.jpg)

加载器种类：
![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载器01.jpg)

类加载器的关系：
![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载器02.jpg)

------------------------

## 类加载器的双亲委托机制

- 在父亲委托机制中，各个加载器按照父子关系形成了`树形结构`，除了根类加载器之外，其余的类加载器都只有且只有一个父加载器。

类加载器双亲委托机制
`（并不是所有的环境下，类加载器都遵循这种委托机制）`：
Sample类的加载会从底向上加载，如果有父加载器，就一直往上，知道根类加载器，如果都不能加载，就由上往下尝试子类加载器加载，最后系统类加载器会加载Sample类。

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载器双亲委托01.jpg)

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/类加载器双亲委托02.jpg)


- Bootstrap ClassLoader：$JAVA_HOME中jre/lib/rt.jar里所有的class，有C++实现，不是ClassLoader的子类
- Extension ClassLoader：负责加载Java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs执行目录下的jar包
- App ClassLoader：负责加载classpath中指定的jar包及目录中的class

有一个类能够成功加载Test类，那么这个类被称为`定义类加载器`，所有能成功返回Class对象引用的类加载器（包括定义类加载器）都被称为`初始类加载器`（例：上述的Sample类是被系统类加载器加载的，所以系统类加载器就是定义类加载器，而loader1能够得到Sample类的Class对象，所有loader1是初始化加载器）

### 案例：

调用getClassLoader方法：可能会使用`null`表示根类加载器加载的类。

```
public class ParentsEntrust {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> clazz = Class.forName("java.lang.String");
        System.out.println(clazz.getClassLoader());

        Class<?> clazz2 = Class.forName("sun.util.resources.ar.CalendarData_ar");
        System.out.println(clazz2.getClassLoader());

        Class<?> clazz3 = Class.forName("com.wang.jvm.C");
        System.out.println(clazz3.getClassLoader());

    }
}

class C {}

结果：
null
sun.misc.Launcher$ExtClassLoader@74a14482
sun.misc.Launcher$AppClassLoader@18b4aac2
```

主动使用：`反射`
Class类中有重写toString，所以会打印当前类
```
public class ClassforNameDemo {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        Class<?> clazz = classLoader.loadClass("com.wang.jvm.CF");
        System.out.println(clazz);

        System.out.println("========================");

        clazz = Class.forName("com.wang.jvm.CF");
        System.out.println(clazz);
    }
}

class CF {
    static {
        System.out.println("Hello CF!");
    }
}

结果：
class com.wang.jvm.CF
========================
Hello CF!
class com.wang.jvm.CF
```

## 双亲委托机制案例：

- getSystemClassLoader()：将系统类加载器返回返回用于委托的系统类加载器。这是新类加载器实例的默认委托父类，通常是用于启动应用程序的类加载器。
- getParent()：找到父加载器 返回用于委托的父类加载器。一些实现可能使用null来表示引导类加载器。如果这个类装入器的父类是引导类装入器，那么这个方法将在这样实现中返回null。
```
public class ClassLoaderDemo {
    public static void main(String[] args) throws IOException {
        ClassLoader loader = ClassLoader.getSystemClassLoader();

        System.out.println(loader);

        while (null != loader) {
            loader = loader.getParent();
            System.out.println(loader);
        }

        System.out.println("==================");

        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        System.out.println(contextClassLoader);

        Enumeration<URL> urls = contextClassLoader.getResources("com/wang/jvm/InitTest.class");
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            System.out.println(url);
        }
    }
}

结果：
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@1b6d3586
null
==================
sun.misc.Launcher$AppClassLoader@18b4aac2
file:/E:/JavaEE/ClassLoad/out/production/classes/com/wang/jvm/InitTest.class
```

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/classloader01.jpg)


## ClassLoader源码

Binary names: 
- 提供为任何类名String在ClassLoader参数的方法必须是The Java™ Language Specification所定义的二进制名称。 
- 有效的类名的示例包括： 
    ```
   "java.lang.String"
   "javax.swing.JSpinner$DefaultEditor" -> JSpsinner类中的DefaultEditor内部类
   "java.security.KeyStore$Builder$FileBuilder$1" -> KeyStore类中的Builder内部类中的FileBuilder内部类中的第一个匿名内部类
   "java.net.URLClassLoader$3$1"
   ```
**ClassLoader：**
- 类加载器是负责加载类的对象。 ClassLoader类是一个抽象类。 给定一个类的binary name，类加载器应该尝试`定位`（数据已存在，能过找到，java.lang.String）或`生成`（动态代理，在运行期生成出来的）构成类的定义的数据。 `典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”`（或者网络传输）。(二进制名称对应的class文件：Test.class，将Test类转换成Test.class文件)

- 每个类对象都会包含定义它的ClassLoader的reference。 

- 针对于数组类的class对象不是由类加载器创建的（`那么其他就一定时类加载器创建的`），而是按照Java运行时的要求时自动创建的。 
Class.getClassLoader()返回的数组类的类加载器与其元素类型的类加载器相同; 如果元素类型是原始类型，则数组类没有类加载器。 
```
System.out.println("============根类加载器===========");
String[] str = new String[1];
System.out.println(str.getClass().getClassLoader());

System.out.println("============系统类加载器===========");
ClassLoaderDemo2[] classLoaderDemo2s = new ClassLoaderDemo2[1];
System.out.println(classLoaderDemo2s.getClass().getClassLoader());

System.out.println("============这里是没有类加载器===========");
int[] ints = new int[1];
System.out.println(ints.getClass().getClassLoader());

结果：
null
=======================
sun.misc.Launcher$AppClassLoader@18b4aac2
=======================
null
```

- 应用程序实现ClassLoader的子类 ，以扩展Java虚拟机动态加载类的方式。(`Java虚拟机默认加载类的方式是双亲委托机制，安全性极好，某些情况需要改变类的加载方式，所有需要扩展`)

- 类加载器通常被安全管理器用来指示安全域。

- ClassLoader类使用委托模式来搜索类和资源。 ClassLoader的每个实例都有一个关联的父类加载器。 当请求查找类或资源时， ClassLoader实例将在尝试查找类或资源本身之前将类或资源的搜索委托给其父类加载器。 虚拟机的内置类加载器（称为“引导类加载器”）本身不具有父级，但可以作为ClassLoader实例的父级。 

- 支持并发加载类的类加载器称为`并行类加载器`，并且要求注册自身在其类初始化期间通过调用`ClassLoader.registerAsParallelCapable`方法注册。 注意：`默认情况下，ClassLoader类已经注册为并行`。 然而，如果它们子类也是可以并行加载的，需要给子类进行注册。
在委托模式不是严格层次化的环境中，类加载器需要并行，否则加载类可能导致死锁，因为加载程序的锁在类加载过程中是一只持有的（参见loadClass方法）。 

- 通常，Java虚拟机以平台相关的方式从本地文件系统加载类。 例如，在UNIX系统上，虚拟机从CLASSPATH环境变量定义的目录加载类。 

- 然而，一些类可能不是源于文件; 它们可以来自诸如网络的其他来源，或者它们可以由应用构建（动态代理）。 defineClass()方法将字节数组转换为class的实例。 想创建这个class真正对应的类的实例，可以使用Class.newInstance()创建我们真正需要的对象。 

- 类加载器创建的对象的方法和构造函数可以引用其他类。 要确定所引用的类，Java虚拟机调用最初创建该类的类加载器的loadClass方法。 

    例如，应用程序可以创建一个网络类加载器来从服务器下载类文件。 示例代码可能如下所示： 

        ClassLoader loader = new NetworkClassLoader(host, port);
        Object main = loader.loadClass("Main", true).newInstance();

    网络类加载器子类必须定义从网络加载类的方法findClass和loadClassData 。 一旦下载构成类的字节，它应该使用方法defineClass创建一个类实例。 示例实现是： 

        class NetworkClassLoader extends ClassLoader {
            String host;
            int port;
        
            /* 
            根据类的名字，调用loadClassData获取字节数组数据，后调用defineClass方法形成一个Class对象，返回给调用者。
            */
            public Class findClass(String name) {
                byte[] b = loadClassData(name);
                return defineClass(name, b, 0, b.length);
            }
            //根据类的名字找到这个类，并返回byte[]类型
            private byte[] loadClassData(String name) {
                // load the class data from the connection
                . . .
            }
        }


## 自定义类加载器

> ClassLoader类中的loadClass的方法就是委托父类加载的方法，如果父类加载不了，就往下走

- 不指定class文件加载路径，默认从out文件夹下加载器class文件，会后系统类加载器加载器该类。
- 指定class文件加载路径，若不删除out目录下的class文件，加载out下的文件，并有系统类加载器加载该类，删除out目录下的class文件，便会加载指定目录下的class文件。


```
public class ComplexClassDemo {
    public static void main(String[] args) throws Exception {
        //直接传进加载器名称，默认将系统类加载器当做该加载器的父类
        MyClassLoader loader = new MyClassLoader("loader");
        //设置class文件加载路径
        loader.setPath("D:/classes/");
        //加载Log类的class字节码文件
        Class<?> clazz = loader.loadClass("com.wang.jvm.custom.Log");
        //创建Log类的实例对象
        Object obj = clazz.newInstance();
        //打印加载Log类的加载器
        System.out.println("类加载器是:" + clazz.getClassLoader());
        //打印Log类的实例对象
        System.out.println(obj);
    }
}

/**
 * 自定义类加载器
 * @auther Mr.Wang
 * @date 2019/9/9 11:30
 */
public class MyClassLoader extends ClassLoader {
    //加载器名
    private String classLoadName;
    //指定加载class文件路径
    private String path = "";
    public void setPath(String path) {
        this.path = path;
    }

    private final String fileExtension = ".class";

    public MyClassLoader(String classLoadName){
        //将系统类加载器当做该类加载器的父加载器
        super();
        this.classLoadName=classLoadName;
    }

    public MyClassLoader(ClassLoader parent, String classLoadName) {
        //指定双亲
        super(parent);
        this.classLoadName = classLoadName;
    }

    /**
     * 重写findClass方法
     * @param className 是我们这个类的全路径
     * @return
     */
    @Override
    protected Class<?> findClass(String className) {
        // 获取该class文件字节码数组
        byte[] classData = loadClassData(className);
        // 将class的字节码数组转换成Class类的实例
        return defineClass(className, classData, 0, classData.length);
    }

    /**
     * 将class文件转化为字节码数组
     * @return
     */
    private byte[] loadClassData(String name) {
        FileInputStream in = null;
        ByteArrayOutputStream out = null;
        name = name.replace(".", "/");
        try {
            in = new FileInputStream(new File(this.path + name + ".class"));
            out = new ByteArrayOutputStream();

            byte[] buffer = new byte[1024];
            int size = 0;
            while ((size = in.read(buffer)) != -1) {
                out.write(buffer, 0, size);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != out){
                    out.close();
                }
                if (null != in){
                    in.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }
        return out.toByteArray();
    }
}

结果：
（未）指定路径：未删除out下的class文件
类加载器是:sun.misc.Launcher$AppClassLoader@18b4aac2
com.wang.jvm.custom.Log@1540e19d

指定路径：删除out下的class文件
类加载器是:com.wang.jvm.custom.MyClassLoader@1540e19d
com.wang.jvm.custom.Log@14ae5a5
```



加载方式：
- Class.forName()：将类.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
- Class.forName(name, initialize, loader)：带参数可控制是否加载static块，并且只有调用newInstance()方法采用调用构造函数，创建类的对象。
- ClassLoader.loaderClass()：只干一件事，将.class文件加载到jvm中，只有在newInstance才会去执行static块。

-------------------------------------

-------------------------------------

## 引入命名空间

```
//这个类class的路径
MyClassLoader myClassLoader = new MyClassLoader("myClassLoader");
myClassLoader.setPath("D:/classes/");
//加载Log这个class文件
Class<?> log = myClassLoader.loadClass("com.wang.jvm.custom.Log");
Object object = log.newInstance();
System.out.println("类加载器是:" + log.getClassLoader());
System.out.println("hashcode: " + log.hashCode());
System.out.println(object);

System.out.println();

MyClassLoader myClassLoader2 = new MyClassLoader("myClassLoader");
myClassLoader2.setPath("D:/classes/");
//加载Log这个class文件
Class<?> log2 = myClassLoader2.loadClass("com.wang.jvm.custom.Log");
Object object2 = log2.newInstance();
System.out.println("类加载器是:" + log2.getClassLoader());
System.out.println("hashcode: " + log2.hashCode());
System.out.println(object2);
```

- 不删除out目录下的Log.class文件（hashcode值相同）：第一次是由MyClassLoader加载器的父类APPClassLoader加载，第二次是直接引用第一次加载的。
```
类加载器是:sun.misc.Launcher$AppClassLoader@18b4aac2
hashcode: 356573597
com.wang.jvm.custom.Log@677327b6

类加载器是:sun.misc.Launcher$AppClassLoader@18b4aac2
hashcode: 356573597
com.wang.jvm.custom.Log@14ae5a5
```

- 删除out目录下的Log.class文件（hashcode值不同），指定加载路径：是由MyClassLoader加载器单独加载两个类。
```
类加载器是:com.wang.jvm.custom.MyClassLoader@1540e19d
hashcode: 21685669
com.wang.jvm.custom.Log@7f31245a

类加载器是:com.wang.jvm.custom.MyClassLoader@6d6f6e28
hashcode: 1173230247
com.wang.jvm.custom.Log@330bedb4
```



------------------------------------

## 命名空间

- 每个类加载器都有自己的命名空间，`命名空间由该加载器及所有父加载器所加载的类组成`。
- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。
- 在不同的命名空间中，有可能出现两个类的完整名字（包括类的包名）相同的两个类。

------------------------------------

## 类的卸载

- 当Sample类被加载、连接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而技术Sample类的生命周期。
- 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
- 由`Java虚拟机自带的类加载器`（根类、扩展类和系统类加载器）`所加载的类`，在虚拟机的生命周期中，`始终不会被卸载`。（因为jvm本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的）。
- 由用户自定义的类加载器所加载的类是可以被卸载的。

### 案例：

以下案例，需要指定路径，删除out下的class文件，因为由`jvm自带的加载器所加载的类，在jvm的生命周期中，始终不会被卸载`，所以指定路径加载class文件。

- 在添加vm option中添加参数：-XX:+TraceClassLoading，可查看类的卸载过程
- 在git中输入`jvisualvm`可进入可视化的类卸载过程进行查看

```
MyClassLoader loader1 = new MyClassLoader("loader1");
loader1.setPath("D:/classes/");
//加载Log这个class文件
Class<?> clazz1 = loader1.loadClass("com.wang.jvm.custom.Log");
Object object1 = clazz1.newInstance();
System.out.println("类加载器是:" + clazz1.getClassLoader());
System.out.println("hashcode: " + clazz1.hashCode());
System.out.println(object1);

System.out.println();

loader1 = null;
clazz1 = null;
object1 = null;

System.gc();

//Thread.sleep(200000);

System.out.println();

loader1 = new MyClassLoader("loader1");
loader1.setPath("D:/classes/");
//加载Log这个class文件
clazz1 = loader1.loadClass("com.wang.jvm.custom.Log");
object1 = clazz1.newInstance();
System.out.println("类加载器是:" + clazz1.getClassLoader());
System.out.println("hashcode: " + clazz1.hashCode());
System.out.println(object1);

结果：
类加载器是:com.wang.jvm.custom.MyClassLoader@1540e19d
hashcode: 21685669
com.wang.jvm.custom.Log@7f31245a

[Unloading class com.wang.jvm.custom.Log 0x0000000100061028]

类加载器是:com.wang.jvm.custom.MyClassLoader@6d6f6e28
hashcode: 1173230247
com.wang.jvm.custom.Log@330bedb4
```


