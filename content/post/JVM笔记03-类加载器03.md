---
title: "JVM笔记03-类加载器03"
date: 2019-09-10T08:14:16+08:00
author: CoderLeftEar
tags: ["JVM"]
categories: ["JVM"]
draft: true
---

# JVM笔记03-类加载器03

------------------------------------------


<!-- TOC -->

- [JVM笔记03-类加载器03](#jvm笔记03-类加载器03)
    - [自定义类加载器在复杂类加载情况下运动分析](#自定义类加载器在复杂类加载情况下运动分析)
    - [类加载器命名空间实战与彻底理解](#类加载器命名空间实战与彻底理解)
        - [1.](#1)
        - [2.](#2)
    - [类加载器实例剖析与疑难点解析](#类加载器实例剖析与疑难点解析)
        - [BootstrapClassLoader](#bootstrapclassloader)
        - [ExtensionClassLoader](#extensionclassloader)
    - [类加载器命名空间深度解析](#类加载器命名空间深度解析)
        - [例1：](#例1)
        - [例2：](#例2)
        - [类加载器的双亲委托模型的好处](#类加载器的双亲委托模型的好处)
    - [扩展类加载器和总结](#扩展类加载器和总结)
        - [启动类加载器的相关](#启动类加载器的相关)
    - [Launcher源码分析和forName源码分析](#launcher源码分析和forname源码分析)
    - [线程上下文类加载器的分析与事项（setContextClassLoader();）](#线程上下文类加载器的分析与事项setcontextclassloader)
        - [例1：](#例1-1)
        - [例2：ServiceLoader案例](#例2serviceloader案例)
        - [例3：](#例3)
    - [jar hell问题](#jar-hell问题)

<!-- /TOC -->


## 自定义类加载器在复杂类加载情况下运动分析

<font color='red' size=5>案例在上一篇</font>

注释掉clazz.newInstance();就不会实例化MyDog对象，即MyDog的构造方法不会被调用，因此不会实例化MyCat对象，没有对MyCat进行主动使用。`但并不代表MyDog没有被加载`。
```
注释掉clazz.newInstance():
[Loaded com.wang.jvm.custom.MyDog from file:/E:/JavaEE/ClassLoad/out/production/classes/]
hashcode: 356573597

没有注释掉clazz.newInstance():
[Loaded com.wang.jvm.custom.MyDog from file:/E:/JavaEE/ClassLoad/out/production/classes/]
hashcode: 356573597
invoke dog class constructor!sun.misc.Launcher$AppClassLoader@18b4aac2
[Loaded com.wang.jvm.custom.MyCat from file:/E:/JavaEE/ClassLoad/out/production/classes/]
invoke cat class constructor!sun.misc.Launcher$AppClassLoader@18b4aac2
```

```
MyClassLoader loader = new MyClassLoader("loader");
Class<?> clazz = loader.loadClass("com.wang.jvm.custom.MyDog");
System.out.println("hashcode: " + clazz.hashCode());
//创建MyDog1的实例
clazz.newInstance();

public class MyDog {
    public MyDog() throws ClassNotFoundException {
        System.out.println("invoke dog class constructor!" + this.getClass().getClassLoader());
        new MyCat();
    }
}

public class MyCat {
    public MyCat() {
        System.out.println("invoke cat class constructor!" + this.getClass().getClassLoader());
    }
}

```

----------------------------------------

## 类加载器命名空间实战与彻底理解

### 1.

在指定目录的情况下：

```
MyClassLoader loader = new MyClassLoader("loader");
loader.setPath("D:/classes/");

Class<?> clazz = loader.loadClass("com.wang.jvm.custom.MyDog");

System.out.println("hashcode: " + clazz.hashCode());

//创建MyDog1的实例
clazz.newInstance();
```

- 删除MyDog：dog由自定义加载器加载，cat由系统类加载器加载。（dog类：先由下到上，在由上到下，只有自定义加载器能够加载。cat类：系统类加载器能够加载cat类）
```
com.wang.jvm.custom.MyDog===============loader
hashcode: 21685669
invoke dog class constructor!com.wang.jvm.custom.MyClassLoader@1540e19d
invoke cat class constructor!sun.misc.Launcher$AppClassLoader@18b4aac2
```

- 删除MyCat类（运行报错：java.lang.NoClassDefFoundError: com/wang/jvm/custom/MyCat）：dog类系统类加载器能够加载，而cat类只能有自定义加载器加载（`父加载器不能访问子加载器，子加载器能够访问父加载器`）

- 加载指定目录下的class文件

```
com.wang.jvm.custom.MyDog===============loader
hashcode: 21685669
invoke dog class constructor!com.wang.jvm.custom.MyClassLoader@1540e19d
com.wang.jvm.custom.MyCat===============loader
invoke cat class constructor!com.wang.jvm.custom.MyClassLoader@1540e19d
```

- 至于其他情况，未来的我，你自己想吧，现在我不想写了`: <`


### 2.

- 在MyCat类中添加`System.out.println(MyDog.class);`，删除out下的dog的class文件，运行报错（原因：和命名空间（由该类加载器和其父类加载器所加载的类组成）有关，由于dog的class文件已经被删除，所以由自定义加载器加载，但cat类的class文件没有删除，在dog类中new的cat对象会有系统类加载器加载，但由于`命名空间`的原因，有系统类加载器加载的cat中包含打印dog.class的代码，但父不能访问子，所有报错：java.lang.NoClassDefFoundError: com/wang/jvm/custom/MyDog）

- 这里脑子有点乱，未来的我，你自己考虑吧！

--------------------------------------------

## 类加载器实例剖析与疑难点解析

- 查看jvm的三个自带的类加载器加载的文件：
```
System.out.println(System.getProperty("sun.boot.class.path"));
System.out.println(System.getProperty("java.ext.dirs"));
System.out.println(System.getProperty("java.class.path"));

结果：
根类加载器：
C:\Program Files\Java\jdk1.8.0_192\jre\lib\resources.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\rt.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_192\jre\lib\jsse.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jce.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\charsets.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jfr.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\classes

扩展类加载器：
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext;
C:\Windows\Sun\Java\lib\ext

应用类加载器：
C:\Program Files\Java\jdk1.8.0_192\jre\lib\charsets.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\deploy.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\access-bridge-64.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\cldrdata.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\dnsns.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\jaccess.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\jfxrt.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\localedata.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\nashorn.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\sunec.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\sunjce_provider.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\sunmscapi.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\sunpkcs11.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\ext\zipfs.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\javaws.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jce.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jfr.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jfxswt.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\jsse.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\management-agent.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\plugin.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\resources.jar;
C:\Program Files\Java\jdk1.8.0_192\jre\lib\rt.jar;
E:\JavaEE\ClassLoad\out\production\classes;
C:\Users\Mr.Wang\.gradle\caches\modules-2\files-2.1\org.projectlombok\lombok\1.18.8\448003bc1b234aac04b58e27d7755c12c3ec4236\lombok-1.18.8.jar;
D:\IntelliJ IDEA 2018.3.1\lib\idea_rt.jar
```

### BootstrapClassLoader
- 在`C:\Program Files\Java\jdk1.8.0_192\jre\classes`目录下放项目本身的out目录下的classes文件夹下的com文件夹，执行代码，执行结果：`null`。由此更能体现出父子类加载器之间的关系。

### ExtensionClassLoader

```
AESKeyGenerator aesKeyGenerator = new AESKeyGenerator();
System.out.println(aesKeyGenerator.getClass().getClassLoader());
System.out.println(BootstrapClassLoaderDemo.class.getClassLoader());

结果：
sun.misc.Launcher$ExtClassLoader@12a3a380
sun.misc.Launcher$AppClassLoader@18b4aac2
```

## 类加载器命名空间深度解析

### 例1：

未删除任何class文件，由下而上，最后会有APPClassLoader加载，结果为`true`。
```
MyClassLoader loader1 = new MyClassLoader("loader1");
MyClassLoader loader2 = new MyClassLoader("loader2");

Class<?> clazz1 = loader1.loadClass("com.wang.jvm.ClassLoaderLoadClass.Person");
Class<?> clazz2 = loader2.loadClass("com.wang.jvm.ClassLoaderLoadClass.Person");

//加载同一个类，第二次直接引用第一次的加载
System.out.println(clazz1 == clazz2);

//创建对象
Object object1 = clazz1.newInstance();
Object object2 = clazz2.newInstance();

//使用反射获取clazz1对象的setPerson方法，参数为Object类型
Method method = clazz1.getMethod("setPerson", Object.class);
//调用object1对象的setPerson方法传入object2对象
method.invoke(object1, object2);
```

### 例2：

指定加载目录，删除Person.class文件后，所以会由MyClassLoader类加载器加载Person的class文件，得到loader1和loader2，但因为`命名空间`的关系，所以这两个类加载器没有任何关系，都有自己的命名空间，`不同命名空间之间的类不可见`，所以为false；
至于抛异常，是因为不同命名空间之间类不可见。
```
MyClassLoader loader1 = new MyClassLoader("loader1");
MyClassLoader loader2 = new MyClassLoader("loader2");

loader1.setPath("D:/classes/");
loader2.setPath("D:/classes/");

Class<?> clazz1 = loader1.loadClass("com.wang.jvm.ClassLoaderLoadClass.Person");
Class<?> clazz2 = loader2.loadClass("com.wang.jvm.ClassLoaderLoadClass.Person");

//加载同一个类，第二次直接引用第一次的加载
System.out.println(clazz1 == clazz2);

//创建对象
Object object1 = clazz1.newInstance();
Object object2 = clazz2.newInstance();

//使用反射获取clazz1对象的setPerson方法，参数为Object类型
Method method = clazz1.getMethod("setPerson", Object.class);
//调用object1对象的setPerson方法传入object2对象
method.invoke(object1, object2);

结果：
com.wang.jvm.ClassLoaderLoadClass.Person===============loader1
com.wang.jvm.ClassLoaderLoadClass.Person===============loader2
false
Exception in thread "main" java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.wang.jvm.ClassLoaderLoadClass.NameSpaceDemo2.main(NameSpaceDemo2.java:33)
Caused by: java.lang.ClassCastException: com.wang.jvm.ClassLoaderLoadClass.Person cannot be cast to com.wang.jvm.ClassLoaderLoadClass.Person
	at com.wang.jvm.ClassLoaderLoadClass.Person.setPerson(Person.java:12)
	... 5 more

```

### 类加载器的双亲委托模型的好处

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/双亲委托的好处.jpg)

## 扩展类加载器和总结

```
public class NameSpaceDemo3 {
    static {
        System.out.println("initial loading");
    }
    public static void main(String[] args) {
        System.out.println(Person.class.getClassLoader());
        System.out.println(NameSpaceDemo1.class.getClassLoader());
    }
}
```

- 修改扩展类加载器在运行期时加载的目录，后面是需要运行的类，但还是由APPClassLoader加载。
```
$ java -Djava.ext.dirs=./ com.wang.jvm.ClassLoaderLoadClass.NameSpaceDemo3
initial loading
sun.misc.Launcher$AppClassLoader@73d16e93
sun.misc.Launcher$AppClassLoader@73d16e93

```

- 原因是：扩展类加载器加载方式不一样，不能直接加载器class文件，需要达成jar包(`打包类加载器加载的类，不是打包需要运行的类`)。
```
$ jar cvf NameSpaceDemo3.jar com/wang/jvm/ClassLoaderLoadClass/NameSpaceDemo1.class
已添加清单
正在添加: com/wang/jvm/ClassLoaderLoadClass/NameSpaceDemo1.class(输入 = 1626) (输出 = 831)(压缩了 48%)

Mr.Wang@Mr-Wang MINGW64 /e/JavaEE/ClassLoad/out/production/classes
$ java -Djava.ext.dirs=./ com.wang.jvm.ClassLoaderLoadClass.NameSpaceDemo3
initial loading
sun.misc.Launcher$AppClassLoader@2a139a55
sun.misc.Launcher$ExtClassLoader@33909752

```

-----------------------------------

### 启动类加载器的相关

-----------------------------------

- **所有的类一定是由类加载器加载的，但数组例外，数组是由jvm加载的。**
- **除根类加载器外的所有加载器也是java类，ext和app它们是由BootstrapClassLoader（由C++编写）加载的。**
- BootstrapClassLoader是内嵌于jvm当中的，jvm启动的时候，一块特殊的机器码会运行（就是启动类加载器），再由boot加载ext和app加载器，最后再加载其他的类。
- 启动类加载器是特定于平台的机器指令，他负责开启整个加载过程。
- 启动类加载器还会负责加载供jre正常运行所需要的基本组件，包括java.util和java.lang包中的类等等。
- **`如果没有特别指定，则用户自定义的类加载器默认都以系统类加载器作为父加载器。`**

-----------------------------------

```
System.out.println(Launcher.class.getClassLoader());

System.out.println(ClassLoader.class.getClassLoader());

System.out.println("---------------------------------");

System.out.println(System.getProperty("java.system.class.loader"));

System.out.println(BootMoreDemo.class.getClassLoader());

System.out.println(MyClassLoader.class.getClassLoader());

System.out.println(ClassLoader.getSystemClassLoader());
```

直接运行：  
- Launcher(里面包含app和ext类加载器)和ClassLoader，会由启动类加载器加载。
- 打印"java.system.class.loader"，结果为null，不存在
- BootMoreDemo和MyClassLoader（自定义类加载器默认是APPClassLoader加载的）都是由AppClassLoader加载的，但为什么执行结果为null。
```
null
null
---------------------------------
null
sun.misc.Launcher$AppClassLoader@18b4aac2
null(sun.misc.Launcher$AppClassLoader@18b4aac2)
sun.misc.Launcher$AppClassLoader@18b4aac2
```

通过控制台命令运行：  
- 指定"java.system.class.loader"的值是自定义的MyClassLoader类加载器，运行BootMoreDemo类。
- Launcher和ClassLoader还是由启动类加载器加载。
- 指定"java.system.class.loader"的值之后，打印结果变为指定的类加载器。
- BootMoreDemo和MyClassLoader还是由系统类加载器加载。
- `ClassLoader.getSystemClassLoader()`：结果为`MyClassLoader`。

`getSystemClassLoader()`：返回用于委托的系统类加载器。这是新类加载器实例的默认委托父类，通常是用于启动应用程序的类加载器。

```
$ java -Djava.system.class.loader=com.wang.jvm.custom.MyClassLoader com.wang.jvm.ClassLoaderLoadClass.BootMoreDemo
null
null
---------------------------------
com.wang.jvm.custom.MyClassLoader
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$AppClassLoader@18b4aac2
com.wang.jvm.custom.MyClassLoader@6d06d69c
```

---------------------------------

## Launcher源码分析和forName源码分析

听不懂，笔记也不想做，烦死了！下一个！

---------------------------------

## 线程上下文类加载器的分析与事项（setContextClassLoader();）

`setContextClassLoader`（线程上下文类加载器）：
存在的主要作用：为了改变双亲委托模型在某些场景下不太适用，或者无法满足我们需求的这样的境况。

`当前类加载器(Current ClassLoader)`

- 每个类都会使用加载自身的类加载器去加载其他引用的类（如果Class A 引用了Class B ，那么加载了A的类加载器就会去加载B（但前提是B没有被加载））。

`线程上下文加载器(Context ClassLoader)`

- 线程上下文类加载器从jdk1.2开始引入，类Thread中的getContextClassLoader()与serContextClassLoader(ClassLoader c)分别用来获取和设置上下文类加载器。
- 如果没有通过set进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文加载器是系统类加载器。在线程中运行的代码可以通过加载器来加载类与资源。

线程上下文加载器的重要性：
`SPI(Service Provider Interface)`

- 父ClassLoader可以使用当前线程Threa.currentThread().getContextClassLoader()所指定的ClassLoader来加载类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载类的情况，即改变了双亲委托模型。
- 线程上下文类加载器就是当前线程的Current ClassLoader。
- 在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但对于SPI来说，有些接口是Java核心库所提供的，而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以设置的上下文类加载器来实现对于接口实现类的加载。

### 例1：

这里的Thread不是Thread类，是当前线程。
```
public class ContextLoaderDemo2 implements Runnable {

    private Thread thread;

    public ContextLoaderDemo2 () {
        thread = new Thread(this);
        thread.start();
    }

    @Override
    public void run() {
        ClassLoader classLoader = this.thread.getContextClassLoader();

        this.thread.setContextClassLoader(classLoader);

        System.out.println("Class: " + classLoader.getClass());
        System.out.println("Parent: " + classLoader.getParent().getClass());

    }

    public static void main(String[] args) {
        new ContextLoaderDemo2();
    }
}

结果：
Class: class sun.misc.Launcher$AppClassLoader
Parent: class sun.misc.Launcher$ExtClassLoader
```

**`线程上下文类加载器`**：

- 线程上下文类加载器的一般使用模式（获取 - 使用 - 还原）。
    ```
    ClassLoader classLoader = Thread.currentThread.getContextClassLoader();
    try {
        Thread.currentThread().setContextClassLoader(targetTccl);
        myMethod();
    } finally {
        Thread.currentThread().setContextClassLoader(classLoader);
    }
    ```
- myMethod里面调用了Thread.currentThread().getContextClassLoader();获取当前线程的上下文做某些事。
- 如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载的（如果该依赖类之前没有被加载过的话）。
- ContextClassLoader的作用就是为了破坏Java的类加载委托机制。
- 当高层提供了统一的接口让低层去实现，同时又要在高层加载（或实例化）低层的类时，
就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。

### 例2：ServiceLoader案例

如果设置了当前上下文类加载器为AppClassLoader.getParent();因为Driver类位于mysql.jar包中，由AppClassLoader加载，而它的父类是ExtensionClassLoader，所以扩展类加载器加载不到mysql.jar包。

```
//Thread.currentThread().setContextClassLoader(ContextLoaderDemo3.class.getClassLoader().getParent());

ServiceLoader<Driver> serviceLoader = ServiceLoader.load(Driver.class);
Iterator<Driver> iterator = serviceLoader.iterator();

while (iterator.hasNext()) {
    Driver driver = iterator.next();
    System.out.println("driver: " + driver.getClass() + ", loader: " + driver.getClass().getClassLoader());
}

System.out.println("当前线程上下文类加载器：" + Thread.currentThread().getContextClassLoader());
System.out.println("ServerLoader的类加载器：" + ServiceLoader.class.getClassLoader());

结果：
driver: class com.mysql.jdbc.Driver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2
driver: class com.mysql.fabric.jdbc.FabricMySQLDriver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2
当前线程上下文类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
ServerLoader的类加载器：null

设置上下文类加载器后的结果：
//当前线程上下文类加载器：sun.misc.Launcher$ExtClassLoader@677327b6
//ServerLoader的类加载器：null
```

### 例3：

以下是在Class类中：
- Class.forName:
    - 一个参数，未指定类加载器，在forName方法中会指定调用者的类加载器。
    - 多个参数：
      
> return forName0(className, true, ClassLoader.getClassLoader(caller), caller);

    - 各个参数含义：
        ```
        className：指定类名
        true：表示会对其进行初始化。
        第三：使用调用者的类加载器（ContextLoaderDemo4的类加载器AppClassLoader）。
        第四：使用调用者的类名（caller = ContextLoaderDemo4）。
        ```
- DriverManager.getConnection:
    - 这段代码的作用：
      
> result = ( aClass == driver.getClass() ) ? true : false;

    - 检验aClass和driver.getClass()是否是同一个类加载器加载的，命名空间是否相同，因为上下文类加载器可以通过setContextClassLoader改变使用哪个类加载器来加载类。

示例代码：
```
public class ContextLoaderDemo4 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        Class.forName("com.mysql.jdbc.Driver.class");
        DriverManager.getConnection("jdbc:mysql://localhost:3306/testdb", "username", "password");
        
    }
}
```

## jar hell问题

![](https://raw.githubusercontent.com/CoderLeftEar/Blog-Images/master/blog/jarHell.jpg)


```
public class JarHellDemo {
    public static void main(String[] args) throws IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

        String resourceName = "java/lang/Long.class";

        Enumeration<URL> urls = classLoader.getResources(resourceName);

        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            System.out.println(url);
        }

    }
}

结果：
jar:file:/C:/Program%20Files/Java/jdk1.8.0_192/jre/lib/rt.jar!/java/lang/Long.class
jar:file:/C:/Program%20Files/Java/jdk1.8.0_192/jre/lib/rt.jar!/java/lang/Long.class
```


